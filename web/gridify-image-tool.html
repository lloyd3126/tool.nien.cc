<!DOCTYPE html>
<html lang="zh-Hant">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>圖片網格化參考工具 (含主網格線)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=Noto+Sans+TC:wght@400;500;700&display=swap"
        rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', 'Noto Sans TC', sans-serif;
        }

        .control-btn {
            background-color: #4f46e5;
            color: white;
            border: none;
            padding: 0.6rem 1.2rem;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            font-weight: 500;
        }

        .control-btn:hover {
            background-color: #4338ca;
        }

        .control-btn:active {
            transform: scale(0.98);
        }

        .control-btn:disabled {
            background-color: #374151;
            cursor: not-allowed;
        }

        input[type="file"]::file-selector-button {
            background-color: #4f46e5;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        input[type="file"]::file-selector-button:hover {
            background-color: #4338ca;
        }

        input[type=range] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            cursor: pointer;
            outline: none;
            border-radius: 1rem;
            height: 0.5rem;
            background: #374151;
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            height: 1.5rem;
            width: 1.5rem;
            background-color: #818cf8;
            border-radius: 50%;
            border: none;
            transition: background-color 0.2s;
        }

        input[type=range]::-webkit-slider-thumb:hover {
            background-color: #6366f1;
        }

        input[type="color"] {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: 3rem;
            height: 2.5rem;
            padding: 0;
            border: none;
            background-color: transparent;
            cursor: pointer;
        }

        input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
        }

        input[type="color"]::-webkit-color-swatch {
            border-radius: 0.375rem;
            border: 1px solid #4b5563;
        }

        #grid-container {
            display: grid;
            grid-template-columns: auto 1fr;
            grid-template-rows: auto 1fr;
            background-color: #1f2937;
            width: 100%;
            max-width: 100%;
            overflow: auto;
        }

        canvas {
            display: block;
            max-width: 100%;
            height: auto;
        }
    </style>
</head>

<body class="bg-gray-900 text-gray-200 flex flex-col items-center min-h-screen p-4 sm:p-8">

    <div class="w-full max-w-5xl">
        <header class="text-center mb-8">
            <h1 class="text-3xl sm:text-4xl font-bold text-white">圖片網格化參考工具</h1>
            <p class="text-gray-400 mt-2">精確定位、計數、參考並修改您的圖片網格</p>
        </header>

        <div class="bg-gray-800 p-6 rounded-xl shadow-lg mb-8 space-y-6">
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6 items-center">
                <div>
                    <label class="block mb-2 text-sm font-medium text-gray-300">1. 選擇圖片</label>
                    <input type="file" id="imageUploader" accept="image/*"
                        class="block w-full text-sm text-gray-400 file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold">
                </div>
                <div class="self-end">
                    <button id="downloadBtn" class="control-btn w-full" disabled>下載網格圖片</button>
                </div>
            </div>
            <div>
                <label class="block mb-2 text-sm font-medium text-gray-300">2. 調整顆粒大小 (Pixel Size)</label>
                <div class="flex items-center space-x-4">
                    <input id="tileSizeSlider" type="range" min="10" max="150" value="40" class="w-full">
                    <span id="tileSizeValue" class="text-lg font-semibold text-indigo-300 w-12 text-center">40</span>
                </div>
            </div>
            <!-- Color Editor Section -->
            <div id="color-editor" class="hidden space-y-4 transition-all">
                <div>
                    <label class="block text-sm font-medium text-gray-300">3. 修改選定方格顏色</label>
                    <div class="flex items-center space-x-4 bg-gray-900 p-3 rounded-lg mt-2">
                        <label for="colorPicker" class="text-sm font-medium">選取顏色:</label>
                        <input type="color" id="colorPicker" value="#ffffff">
                        <button id="resetColorBtn"
                            class="control-btn bg-yellow-600 hover:bg-yellow-700 !py-2 !px-4 text-sm">重置為原始顏色</button>
                    </div>
                </div>
                <!-- Suggested Colors Section -->
                <div class="space-y-2">
                    <label class="block text-sm font-medium text-gray-300">建議顏色 (周圍 10x10 區域)</label>
                    <div id="suggested-colors"
                        class="flex flex-wrap gap-2 p-3 bg-gray-900 rounded-lg min-h-[3.5rem] items-center">
                        <span class="text-gray-500 text-sm">點擊方格以產生建議</span>
                    </div>
                </div>
            </div>
            <div id="info-panel" class="bg-gray-900 p-4 rounded-lg text-center h-16 flex items-center justify-center">
                <span id="info-text" class="text-gray-400">請上傳圖片以開始</span>
            </div>
        </div>

        <div id="grid-container" class="w-full rounded-lg overflow-hidden shadow-inner">
        </div>
    </div>

    <script>
        const imageUploader = document.getElementById('imageUploader');
        const tileSizeSlider = document.getElementById('tileSizeSlider');
        const tileSizeValue = document.getElementById('tileSizeValue');
        const gridContainer = document.getElementById('grid-container');
        const downloadBtn = document.getElementById('downloadBtn');
        const infoText = document.getElementById('info-text');
        const colorEditor = document.getElementById('color-editor');
        const colorPicker = document.getElementById('colorPicker');
        const resetColorBtn = document.getElementById('resetColorBtn');
        const suggestedColorsContainer = document.getElementById('suggested-colors');

        let topRulerCanvas, leftRulerCanvas, mosaicCanvas;

        let originalImage = null;
        let originalImageCanvas = null;
        let originalImageCtx = null;

        let currentTileSize = 40;
        let selectedCell = null;
        let customColors = {};
        const RULER_SIZE = 35;

        tileSizeValue.textContent = `${currentTileSize}`;

        imageUploader.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    originalImage = new Image();
                    originalImage.onload = () => {
                        originalImageCanvas = document.createElement('canvas');
                        originalImageCanvas.width = originalImage.width;
                        originalImageCanvas.height = originalImage.height;
                        originalImageCtx = originalImageCanvas.getContext('2d');
                        originalImageCtx.drawImage(originalImage, 0, 0);

                        downloadBtn.disabled = false;
                        infoText.textContent = '點擊任意方格以顯示座標';
                        colorEditor.classList.add('hidden');
                        suggestedColorsContainer.innerHTML = '<span class="text-gray-500 text-sm">點擊方格以產生建議</span>';
                        customColors = {};
                        selectedCell = null;
                        setupCanvases();
                        drawAll();
                    };
                    originalImage.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }
        });

        tileSizeSlider.addEventListener('input', (event) => {
            currentTileSize = parseInt(event.target.value);
            tileSizeValue.textContent = `${currentTileSize}`;
            if (originalImage) {
                selectedCell = null;
                customColors = {};
                infoText.textContent = '點擊任意方格以顯示座標。顏色已重置。';
                colorEditor.classList.add('hidden');
                suggestedColorsContainer.innerHTML = '<span class="text-gray-500 text-sm">點擊方格以產生建議</span>';
                requestAnimationFrame(drawAll);
            }
        });

        downloadBtn.addEventListener('click', () => {
            if (mosaicCanvas) {
                const link = document.createElement('a');
                link.download = 'grid-image.png';
                const cellToRestore = selectedCell;
                selectedCell = null;
                drawAll();
                link.href = mosaicCanvas.toDataURL('image/png');
                link.click();
                selectedCell = cellToRestore;
                drawAll();
            }
        });

        colorPicker.addEventListener('input', (e) => {
            if (selectedCell) {
                const key = `${selectedCell.col},${selectedCell.row}`;
                customColors[key] = e.target.value;
                drawAll();
            }
        });

        resetColorBtn.addEventListener('click', () => {
            if (selectedCell) {
                const key = `${selectedCell.col},${selectedCell.row}`;
                delete customColors[key];
                drawAll();
                colorPicker.value = getOriginalCellColorAsHex(selectedCell.col, selectedCell.row);
            }
        });

        // Add window resize listener for responsive scaling
        window.addEventListener('resize', () => {
            if (originalImage) {
                requestAnimationFrame(drawAll);
            }
        });

        function setupCanvases() {
            gridContainer.innerHTML = '';

            const corner = document.createElement('div');
            topRulerCanvas = document.createElement('canvas');
            leftRulerCanvas = document.createElement('canvas');
            mosaicCanvas = document.createElement('canvas');

            corner.style.gridColumn = '1'; corner.style.gridRow = '1';
            topRulerCanvas.style.gridColumn = '2'; topRulerCanvas.style.gridRow = '1';
            leftRulerCanvas.style.gridColumn = '1'; leftRulerCanvas.style.gridRow = '2';
            mosaicCanvas.style.gridColumn = '2'; mosaicCanvas.style.gridRow = '2';

            gridContainer.append(corner, topRulerCanvas, leftRulerCanvas, mosaicCanvas);
            mosaicCanvas.addEventListener('click', handleCanvasClick);
        }

        function handleCanvasClick(event) {
            if (!originalImage) return;

            const rect = mosaicCanvas.getBoundingClientRect();
            const scaleX = mosaicCanvas.width / rect.width;
            const scaleY = mosaicCanvas.height / rect.height;

            const canvasX = (event.clientX - rect.left) * scaleX;
            const canvasY = (event.clientY - rect.top) * scaleY;

            // Calculate the actual scale being used
            const containerWidth = gridContainer.clientWidth - RULER_SIZE;
            const displayScale = containerWidth / originalImage.width;
            const scaledTileSize = currentTileSize * displayScale;

            const col = Math.floor(canvasX / scaledTileSize);
            const row = Math.floor(canvasY / scaledTileSize);

            selectedCell = { col, row };
            infoText.innerHTML = `選取位置: <span class="text-indigo-300 font-semibold">行 ${row + 1}, 列 ${col + 1}</span>`;

            colorEditor.classList.remove('hidden');
            const key = `${col},${row}`;
            colorPicker.value = customColors[key] || getOriginalCellColorAsHex(col, row);

            updateSuggestedColors(col, row);
            drawAll();
        }

        function updateSuggestedColors(centerCol, centerRow) {
            suggestedColorsContainer.innerHTML = '';

            if (!originalImage) {
                suggestedColorsContainer.innerHTML = '<span class="text-gray-500 text-sm">請先上傳圖片</span>';
                return;
            }

            const suggestions = new Set();
            const numCols = Math.ceil(originalImage.width / currentTileSize);
            const numRows = Math.ceil(originalImage.height / currentTileSize);

            const startCol = Math.max(0, centerCol - 5);
            const endCol = Math.min(numCols - 1, centerCol + 4);
            const startRow = Math.max(0, centerRow - 5);
            const endRow = Math.min(numRows - 1, centerRow + 4);

            for (let r = startRow; r <= endRow; r++) {
                for (let c = startCol; c <= endCol; c++) {
                    const colorHex = getOriginalCellColorAsHex(c, r);
                    suggestions.add(colorHex);
                }
            }

            if (suggestions.size === 0) {
                suggestedColorsContainer.innerHTML = '<span class="text-gray-500 text-sm">無鄰近顏色可建議</span>';
                return;
            }

            const sortedColors = Array.from(suggestions).sort((a, b) => {
                const hslA = hexToHsl(a);
                const hslB = hexToHsl(b);
                return hslA.h - hslB.h || hslA.s - hslB.s || hslA.l - hslB.l;
            });

            sortedColors.forEach(color => {
                const swatch = document.createElement('button');
                swatch.className = 'w-8 h-8 rounded-md border border-gray-600 cursor-pointer transition-transform duration-100 hover:scale-110 hover:border-indigo-400 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-900 focus:ring-indigo-500';
                swatch.style.backgroundColor = color;
                swatch.title = `使用顏色 ${color}`;
                swatch.setAttribute('aria-label', `Use color ${color}`);

                swatch.addEventListener('click', (e) => {
                    e.preventDefault();
                    colorPicker.value = color;
                    colorPicker.dispatchEvent(new Event('input', { bubbles: true }));
                });

                suggestedColorsContainer.appendChild(swatch);
            });
        }

        function hexToHsl(hex) {
            let r = 0, g = 0, b = 0;
            if (hex.length == 4) {
                r = parseInt(hex[1] + hex[1], 16);
                g = parseInt(hex[2] + hex[2], 16);
                b = parseInt(hex[3] + hex[3], 16);
            } else if (hex.length == 7) {
                r = parseInt(hex.substring(1, 3), 16);
                g = parseInt(hex.substring(3, 5), 16);
                b = parseInt(hex.substring(5, 7), 16);
            }
            r /= 255; g /= 255; b /= 255;
            let max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;

            if (max == min) {
                h = s = 0;
            } else {
                let d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h /= 6;
            }
            return { h: h * 360, s: s * 100, l: l * 100 };
        }

        function drawAll() {
            if (!originalImage) return;

            const containerWidth = gridContainer.clientWidth - RULER_SIZE;
            const imgWidth = originalImage.width;
            const imgHeight = originalImage.height;

            // Calculate scale to fit width
            const scale = containerWidth / imgWidth;
            const scaledWidth = imgWidth * scale;
            const scaledHeight = imgHeight * scale;

            mosaicCanvas.width = scaledWidth;
            mosaicCanvas.height = scaledHeight;
            topRulerCanvas.width = scaledWidth;
            topRulerCanvas.height = RULER_SIZE;
            leftRulerCanvas.width = RULER_SIZE;
            leftRulerCanvas.height = scaledHeight;

            drawMosaic(scale);
            drawRulers(scale);
            drawHighlight(scale);
        }

        function drawMosaic(scale = 1) {
            const ctx = mosaicCanvas.getContext('2d');
            const imgWidth = mosaicCanvas.width;
            const imgHeight = mosaicCanvas.height;
            const scaledTileSize = currentTileSize * scale;

            // Step 1: Draw all cells and their fine grid
            for (let y = 0; y < imgHeight; y += scaledTileSize) {
                for (let x = 0; x < imgWidth; x += scaledTileSize) {
                    const col = Math.floor(x / scaledTileSize);
                    const row = Math.floor(y / scaledTileSize);
                    const key = `${col},${row}`;

                    ctx.fillStyle = customColors[key] || getOriginalCellColorAsHex(col, row);
                    ctx.fillRect(x, y, scaledTileSize, scaledTileSize);

                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(x + 0.5, y + 0.5, scaledTileSize, scaledTileSize);
                }
            }

            // **NEW**: Step 2: Draw major grid lines over the top to fix rendering glitches
            let labelInterval;
            if (currentTileSize >= 40) labelInterval = 1;
            else if (currentTileSize >= 20) labelInterval = 2;
            else if (currentTileSize >= 15) labelInterval = 5;
            else labelInterval = 10;

            ctx.strokeStyle = '#111827'; // A very dark gray, almost black
            ctx.lineWidth = 2; // Make it clearly visible

            // Draw major vertical lines
            for (let i = labelInterval; i * scaledTileSize < imgWidth; i += labelInterval) {
                const x = i * scaledTileSize;
                ctx.beginPath();
                ctx.moveTo(x - 0.5, 0);
                ctx.lineTo(x - 0.5, imgHeight);
                ctx.stroke();
            }
            // Draw major horizontal lines
            for (let i = labelInterval; i * scaledTileSize < imgHeight; i += labelInterval) {
                const y = i * scaledTileSize;
                ctx.beginPath();
                ctx.moveTo(0, y - 0.5);
                ctx.lineTo(imgWidth, y - 0.5);
                ctx.stroke();
            }
        }

        function getOriginalCellColorAsHex(col, row) {
            if (!originalImageCtx) return '#000000';

            const x = col * currentTileSize;
            const y = row * currentTileSize;
            const centerX = Math.min(x + Math.floor(currentTileSize / 2), originalImage.width - 1);
            const centerY = Math.min(y + Math.floor(currentTileSize / 2), originalImage.height - 1);

            const d = originalImageCtx.getImageData(centerX, centerY, 1, 1).data;
            return "#" + ("000000" + ((d[0] << 16) | (d[1] << 8) | d[2]).toString(16)).slice(-6);
        }

        function drawRulers(scale = 1) {
            const topCtx = topRulerCanvas.getContext('2d');
            const leftCtx = leftRulerCanvas.getContext('2d');
            const imgWidth = mosaicCanvas.width;
            const imgHeight = mosaicCanvas.height;
            const scaledTileSize = currentTileSize * scale;

            topCtx.clearRect(0, 0, topRulerCanvas.width, topRulerCanvas.height);
            leftCtx.clearRect(0, 0, leftRulerCanvas.width, leftRulerCanvas.height);

            let labelInterval;
            if (currentTileSize >= 40) labelInterval = 1;
            else if (currentTileSize >= 20) labelInterval = 2;
            else if (currentTileSize >= 15) labelInterval = 5;
            else labelInterval = 10;

            const textColor = '#cbd5e1', tickColor = '#94a3b8', textFont = '12px Inter';

            topCtx.font = textFont;
            topCtx.textAlign = 'center';
            topCtx.textBaseline = 'middle';
            topCtx.strokeStyle = tickColor;
            topCtx.lineWidth = 1;
            for (let x = 0; x < imgWidth; x += scaledTileSize) {
                const col = Math.floor(x / scaledTileSize) + 1;
                const xPos = x + scaledTileSize / 2;
                topCtx.beginPath();
                topCtx.moveTo(x + 0.5, RULER_SIZE);
                const tickHeight = ((col - 1) % labelInterval === 0) ? 10 : 5;
                topCtx.lineTo(x + 0.5, RULER_SIZE - tickHeight);
                topCtx.stroke();
                if ((col - 1) % labelInterval === 0) {
                    topCtx.fillStyle = textColor;
                    topCtx.fillText(col, xPos, RULER_SIZE - 18);
                }
            }

            leftCtx.font = textFont;
            leftCtx.textAlign = 'center';
            leftCtx.textBaseline = 'middle';
            leftCtx.strokeStyle = tickColor;
            leftCtx.lineWidth = 1;
            for (let y = 0; y < imgHeight; y += scaledTileSize) {
                const row = Math.floor(y / scaledTileSize) + 1;
                const yPos = y + scaledTileSize / 2;
                leftCtx.beginPath();
                leftCtx.moveTo(RULER_SIZE, y + 0.5);
                const tickWidth = ((row - 1) % labelInterval === 0) ? 10 : 5;
                leftCtx.lineTo(RULER_SIZE - tickWidth, y + 0.5);
                leftCtx.stroke();
                if ((row - 1) % labelInterval === 0) {
                    leftCtx.fillStyle = textColor;
                    leftCtx.fillText(row, RULER_SIZE - 18, yPos);
                }
            }
        }

        function drawHighlight(scale = 1) {
            if (!selectedCell) return;
            const ctx = mosaicCanvas.getContext('2d');
            const scaledTileSize = currentTileSize * scale;
            const x = selectedCell.col * scaledTileSize;
            const y = selectedCell.row * scaledTileSize;

            ctx.strokeStyle = '#facc15'; // Yellow-400
            ctx.lineWidth = 4;
            ctx.strokeRect(x + 2, y + 2, scaledTileSize - 4, scaledTileSize - 4);
        }

    </script>
</body>

</html>
